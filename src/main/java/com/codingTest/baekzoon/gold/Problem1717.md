# Problem 1717 - 집합의 표현 (Union-Find)

## 📌 문제 설명

양의 정수 `n`(1 ≤ n ≤ 1,000,000)이 주어지고, `0 a b` 혹은 `1 a b` 형태의 `m`(1 ≤ m ≤ 100,000)개의 연산이 주어진다.

- `0 a b`: `a`가 포함된 집합과 `b`가 포함된 집합을 합친다 (Union).
- `1 a b`: `a`와 `b`가 같은 집합에 포함되어 있는지를 확인한다 (Find).

---

## 💡 사용 알고리즘

### ✅ Union-Find (Disjoint Set Union)

- **`find(x)`**: 원소 x의 루트 노드를 찾는다. 이 과정에서 **경로 압축(Path Compression)**을 사용하여 트리의 높이를 최소화함.
- **`union(a, b)`**: a와 b의 루트 노드를 찾아 한쪽에 병합한다.

---

## 📂 입력 예시

7 8  
0 1 3  
1 1 7  
0 7 6  
1 7 1  
0 3 7  
0 4 2  
0 1 1  
1 1 1  

---

## 🔁 실행 흐름 및 배열 변화

| 연산 | 설명 | `arr` 배열 변화 |
|------|------|------------------|
| 초기 | 모든 원소가 자기 자신을 부모로 가짐 | `0 1 2 3 4 5 6 7` |
| 0 1 3 | union(1, 3) → 3의 부모를 1로 설정 | `0 1 2 1 4 5 6 7` |
| 1 1 7 | find(1) != find(7) → NO | |
| 0 7 6 | union(7, 6) → 6의 부모를 7로 설정 | `0 1 2 1 4 5 7 7` |
| 1 7 1 | find(7)=7, find(1)=1 → NO | |
| 0 3 7 | union(3, 7): 3의 루트는 1, 7의 루트는 7 → 7의 부모를 1로 설정 | `0 1 2 1 4 5 7 1` |
| 0 4 2 | union(4, 2): 2의 부모를 4로 설정 | `0 1 4 1 4 5 7 1` |
| 0 1 1 | union(1, 1): 이미 같은 집합 → 변화 없음 | |
| 1 1 1 | find(1) == find(1) → YES | |

---

## 📌 최종 출력
NO  
NO  
YES  

---
## ⏱ 시간 복잡도
find, union: O(α(N)) — 거의 상수 시간. (여기서 α는 아커만 함수의 역함수)

|연산|	시간 복잡도|
|---|---|
|find()|	O(α(n))|
|union()|	O(α(n))|
|m번의 연산 전체|	O(m · α(n))|
---
## 용어정리
**아커만 함수**: 산량이 매우 빠르게 증가하는 초재귀 함수  
**역 아커만 함수 (α(n))**: 최악의 경우에도 거의 상수 시간으로 작동